<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>dsm.dsm_api API documentation</title>
<meta name="description" content="This module is a wrapper around torch implementations and
provides a convenient API to train Deep Survival Machines." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dsm.dsm_api</code></h1>
</header>
<section id="section-intro">
<p>This module is a wrapper around torch implementations and
provides a convenient API to train Deep Survival Machines.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># coding=utf-8
# Copyright 2020 Chirag Nagpal, Auton Lab.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

&#34;&#34;&#34;
This module is a wrapper around torch implementations and
provides a convenient API to train Deep Survival Machines.
&#34;&#34;&#34;

from dsm.dsm_torch import DeepSurvivalMachinesTorch
from dsm.losses import predict_cdf
from dsm.utilities import train_dsm

import torch

import numpy as np

class DeepSurvivalMachines():
  &#34;&#34;&#34;A Deep Survival Machines model.

  This is the main interface to a Deep Survival Machines model.
  A model is instantiated with approporiate set of hyperparameters and
  fit on numpy arrays consisting of the features, event/censoring times
  and the event/censoring indicators.

  For full details on Deep Survival Machines, refer to our paper [1].

  References
  ----------
  [1] &lt;a href=&#34;https://arxiv.org/abs/2003.01176&#34;&gt;Deep Survival Machines: 
  Fully Parametric Survival Regression and
  Representation Learning for Censored Data with Competing Risks.&#34;
  arXiv preprint arXiv:2003.01176 (2020)&lt;/a&gt;

  Parameters
  ----------
  k: int
      The number of underlying parametric distributions.
  layers: list
      A list of integers consisting of the number of neurons in each
      hidden layer.
  distribution: str
      Choice of the underlying survival distributions.
      One of &#39;Weibull&#39;, &#39;LogNormal&#39;.
      Default is &#39;Weibull&#39;.
  temp: float
      The logits for the gate are rescaled with this value.
      Default is 1000.
  discount: float
      a float in [0,1] that determines how to discount the tail bias
      from the uncensored instances.
      Default is 1.

  Example
  -------
  &gt;&gt;&gt; from dsm import DeepSurvivalMachines
  &gt;&gt;&gt; model = DeepSurvivalMachines()
  &gt;&gt;&gt; model.fit(x, t, e)

  &#34;&#34;&#34;

  def __init__(self, k=3, layers=None, distribution=&#34;Weibull&#34;,
               temp=1000., discount=1.0):
    super(DeepSurvivalMachines, self).__init__()

    self.k = k
    self.layers = layers
    self.dist = distribution
    self.temp = temp
    self.discount = discount
    self.fitted = False

  def __call__(self):
    if self.fitted:
      print(&#34;A fitted instance of the Deep Survival Machines model&#34;)
    else:
      print(&#34;An unfitted instance of the Deep Survival Machines model&#34;)

    print(&#34;Number of underlying distributions (k):&#34;, self.k)
    print(&#34;Hidden Layers:&#34;, self.layers)
    print(&#34;Distribution Choice:&#34;, self.dist)


  def fit(self, x, t, e, vsize=0.15, 
          iters=1, learning_rate=1e-3, batch_size=100,
          elbo=True, optimizer=&#34;Adam&#34;, random_state=100):

    &#34;&#34;&#34;This method is used to train an instance of the DSM model.

    Parameters
    ----------
    x: np.ndarray
        A numpy array of the input features, \( x \).
    t: np.ndarray
        A numpy array of the event/censoring times, \( t \).
    e: np.ndarray
        A numpy array of the event/censoring indicators, \( \delta \).

        \( \delta = 1 \) means the event took place.
    vsize: float
        Amount of data to set aside as the validation set.
    iters: int
        The maximum number of training iterations on the training dataset.
    learning_rate: float
        The learning rate for the `Adam` optimizer.
    batch_size: int
        learning is performed on mini-batches of input data. this parameter
        specifies the size of each mini-batch.
    elbo: bool
        Whether to use the Evidence Lower Bound for Optimization.
        Default is True.
    optimizer: str
        The choice of the gradient based optimization method. One of 
        &#39;Adam&#39;, &#39;RMSProp&#39; or &#39;SGD&#39;.
    random_state: float
        random seed that determines how the validation set is chosen.
    &#34;&#34;&#34;

    idx = list(range(x.shape[0]))
    np.random.seed(random_state)
    np.random.shuffle(idx)
    x_train, t_train, e_train = x[idx], t[idx], e[idx]

    x_train = torch.from_numpy(x_train).double()
    t_train = torch.from_numpy(t_train).double()
    e_train = torch.from_numpy(e_train).double()

    vsize = int(vsize*x_train.shape[0])

    x_val, t_val, e_val = x_train[-vsize:], t_train[-vsize:], e_train[-vsize:]
    x_train = x_train[:-vsize]
    t_train = t_train[:-vsize]
    e_train = e_train[:-vsize]

    inputdim = x_train.shape[1]

    if type(self).__name__ == &#34;DeepSurvivalMachines&#34;:

      model = DeepSurvivalMachinesTorch(inputdim,
                                        k=self.k,
                                        layers=self.layers,
                                        init=False, 
                                        dist=self.dist,
                                        temp=self.temp,
                                        discount=self.discount,
                                        optimizer=optimizer)

      model, _ = train_dsm(model, x_train, t_train, e_train,
                           x_val, t_val, e_val,
                           n_iter=iters,
                           lr=learning_rate,
                           elbo=elbo,
                           bs=batch_size)

      self.torch_model = model.eval()
      self.fitted = True

    else:
      raise NotImplementedError(&#34;`fit` nethod not implemented for &#34;+
                                type(self).__name__)


  def predict_risk(self, x, t):
    &#34;&#34;&#34;Returns the estimated risk of an event occuring before time \( t \),
      \( \widehat{\mathbb{P}}(T\leq t|X) \) for some input data \( x \).

    Parameters
    ----------
    x: np.ndarray
        A numpy array of the input features, \( x \).
    t: list or float
        a list or float of the times at which survival probability is
        to be computed
    Returns:
      np.array: numpy array of the risks at each time in t.
    &#34;&#34;&#34;

    if self.fitted:
      return 1-self.predict_survival(x, t)

    else:
      raise Exception(&#34;The model has not been fitted yet. Please fit the &#34; +
                      &#34;model using the `fit` method on some training data &#34; +
                      &#34;before calling `predict_survival`.&#34;)


  def predict_survival(self, x, t):
    &#34;&#34;&#34;Returns the estimated survival probability at time \( t \),
      \( \widehat{\mathbb{P}}(T &gt; t|X) \) for some input data \( x \).

    Parameters
    ----------
    x: np.ndarray
        A numpy array of the input features, \( x \).
    t: list or float
        a list or float of the times at which survival probability is
        to be computed
    Returns:
      np.array: numpy array of the survival probabilites at each time in t.
    &#34;&#34;&#34;

    if not isinstance(t, list):
      t = [t]

    if self.fitted:
      x = torch.from_numpy(x)
      scores = predict_cdf(self.torch_model, x, t)
      return np.exp(np.array(scores)).T

    else:
      raise Exception(&#34;The model has not been fitted yet. Please fit the &#34; +
                      &#34;model using the `fit` method on some training data &#34; +
                      &#34;before calling `predict_risk`.&#34;)

class DeepRecurrentSurvivalMachines(DeepSurvivalMachines):
  __doc__ = &#34;..warning:: Not Implemented&#34;
  pass

class DeepConvolutionalSurvivalMachines(DeepRecurrentSurvivalMachines):
  __doc__ = &#34;..warning:: Not Implemented&#34;
  pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dsm.dsm_api.DeepConvolutionalSurvivalMachines"><code class="flex name class">
<span>class <span class="ident">DeepConvolutionalSurvivalMachines</span></span>
<span>(</span><span>k=3, layers=None, distribution='Weibull', temp=1000.0, discount=1.0)</span>
</code></dt>
<dd>
<div class="desc"><div class="admonition warning">
<p class="admonition-title">Warning:&ensp;Not Implemented</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeepConvolutionalSurvivalMachines(DeepRecurrentSurvivalMachines):
  __doc__ = &#34;..warning:: Not Implemented&#34;
  pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dsm.dsm_api.DeepRecurrentSurvivalMachines" href="#dsm.dsm_api.DeepRecurrentSurvivalMachines">DeepRecurrentSurvivalMachines</a></li>
<li><a title="dsm.dsm_api.DeepSurvivalMachines" href="#dsm.dsm_api.DeepSurvivalMachines">DeepSurvivalMachines</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dsm.dsm_api.DeepRecurrentSurvivalMachines" href="#dsm.dsm_api.DeepRecurrentSurvivalMachines">DeepRecurrentSurvivalMachines</a></b></code>:
<ul class="hlist">
<li><code><a title="dsm.dsm_api.DeepRecurrentSurvivalMachines.fit" href="#dsm.dsm_api.DeepSurvivalMachines.fit">fit</a></code></li>
<li><code><a title="dsm.dsm_api.DeepRecurrentSurvivalMachines.predict_risk" href="#dsm.dsm_api.DeepSurvivalMachines.predict_risk">predict_risk</a></code></li>
<li><code><a title="dsm.dsm_api.DeepRecurrentSurvivalMachines.predict_survival" href="#dsm.dsm_api.DeepSurvivalMachines.predict_survival">predict_survival</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dsm.dsm_api.DeepRecurrentSurvivalMachines"><code class="flex name class">
<span>class <span class="ident">DeepRecurrentSurvivalMachines</span></span>
<span>(</span><span>k=3, layers=None, distribution='Weibull', temp=1000.0, discount=1.0)</span>
</code></dt>
<dd>
<div class="desc"><div class="admonition warning">
<p class="admonition-title">Warning:&ensp;Not Implemented</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeepRecurrentSurvivalMachines(DeepSurvivalMachines):
  __doc__ = &#34;..warning:: Not Implemented&#34;
  pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dsm.dsm_api.DeepSurvivalMachines" href="#dsm.dsm_api.DeepSurvivalMachines">DeepSurvivalMachines</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="dsm.dsm_api.DeepConvolutionalSurvivalMachines" href="#dsm.dsm_api.DeepConvolutionalSurvivalMachines">DeepConvolutionalSurvivalMachines</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dsm.dsm_api.DeepSurvivalMachines" href="#dsm.dsm_api.DeepSurvivalMachines">DeepSurvivalMachines</a></b></code>:
<ul class="hlist">
<li><code><a title="dsm.dsm_api.DeepSurvivalMachines.fit" href="#dsm.dsm_api.DeepSurvivalMachines.fit">fit</a></code></li>
<li><code><a title="dsm.dsm_api.DeepSurvivalMachines.predict_risk" href="#dsm.dsm_api.DeepSurvivalMachines.predict_risk">predict_risk</a></code></li>
<li><code><a title="dsm.dsm_api.DeepSurvivalMachines.predict_survival" href="#dsm.dsm_api.DeepSurvivalMachines.predict_survival">predict_survival</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dsm.dsm_api.DeepSurvivalMachines"><code class="flex name class">
<span>class <span class="ident">DeepSurvivalMachines</span></span>
<span>(</span><span>k=3, layers=None, distribution='Weibull', temp=1000.0, discount=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>A Deep Survival Machines model.</p>
<p>This is the main interface to a Deep Survival Machines model.
A model is instantiated with approporiate set of hyperparameters and
fit on numpy arrays consisting of the features, event/censoring times
and the event/censoring indicators.</p>
<p>For full details on Deep Survival Machines, refer to our paper [1].</p>
<h2 id="references">References</h2>
<p>[1] <a href="https://arxiv.org/abs/2003.01176">Deep Survival Machines:
Fully Parametric Survival Regression and
Representation Learning for Censored Data with Competing Risks."
arXiv preprint arXiv:2003.01176 (2020)</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>k</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of underlying parametric distributions.</dd>
<dt><strong><code>layers</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of integers consisting of the number of neurons in each
hidden layer.</dd>
<dt><strong><code>distribution</code></strong> :&ensp;<code>str</code></dt>
<dd>Choice of the underlying survival distributions.
One of 'Weibull', 'LogNormal'.
Default is 'Weibull'.</dd>
<dt><strong><code>temp</code></strong> :&ensp;<code>float</code></dt>
<dd>The logits for the gate are rescaled with this value.
Default is 1000.</dd>
<dt><strong><code>discount</code></strong> :&ensp;<code>float</code></dt>
<dd>a float in [0,1] that determines how to discount the tail bias
from the uncensored instances.
Default is 1.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from dsm import DeepSurvivalMachines
&gt;&gt;&gt; model = DeepSurvivalMachines()
&gt;&gt;&gt; model.fit(x, t, e)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeepSurvivalMachines():
  &#34;&#34;&#34;A Deep Survival Machines model.

  This is the main interface to a Deep Survival Machines model.
  A model is instantiated with approporiate set of hyperparameters and
  fit on numpy arrays consisting of the features, event/censoring times
  and the event/censoring indicators.

  For full details on Deep Survival Machines, refer to our paper [1].

  References
  ----------
  [1] &lt;a href=&#34;https://arxiv.org/abs/2003.01176&#34;&gt;Deep Survival Machines: 
  Fully Parametric Survival Regression and
  Representation Learning for Censored Data with Competing Risks.&#34;
  arXiv preprint arXiv:2003.01176 (2020)&lt;/a&gt;

  Parameters
  ----------
  k: int
      The number of underlying parametric distributions.
  layers: list
      A list of integers consisting of the number of neurons in each
      hidden layer.
  distribution: str
      Choice of the underlying survival distributions.
      One of &#39;Weibull&#39;, &#39;LogNormal&#39;.
      Default is &#39;Weibull&#39;.
  temp: float
      The logits for the gate are rescaled with this value.
      Default is 1000.
  discount: float
      a float in [0,1] that determines how to discount the tail bias
      from the uncensored instances.
      Default is 1.

  Example
  -------
  &gt;&gt;&gt; from dsm import DeepSurvivalMachines
  &gt;&gt;&gt; model = DeepSurvivalMachines()
  &gt;&gt;&gt; model.fit(x, t, e)

  &#34;&#34;&#34;

  def __init__(self, k=3, layers=None, distribution=&#34;Weibull&#34;,
               temp=1000., discount=1.0):
    super(DeepSurvivalMachines, self).__init__()

    self.k = k
    self.layers = layers
    self.dist = distribution
    self.temp = temp
    self.discount = discount
    self.fitted = False

  def __call__(self):
    if self.fitted:
      print(&#34;A fitted instance of the Deep Survival Machines model&#34;)
    else:
      print(&#34;An unfitted instance of the Deep Survival Machines model&#34;)

    print(&#34;Number of underlying distributions (k):&#34;, self.k)
    print(&#34;Hidden Layers:&#34;, self.layers)
    print(&#34;Distribution Choice:&#34;, self.dist)


  def fit(self, x, t, e, vsize=0.15, 
          iters=1, learning_rate=1e-3, batch_size=100,
          elbo=True, optimizer=&#34;Adam&#34;, random_state=100):

    &#34;&#34;&#34;This method is used to train an instance of the DSM model.

    Parameters
    ----------
    x: np.ndarray
        A numpy array of the input features, \( x \).
    t: np.ndarray
        A numpy array of the event/censoring times, \( t \).
    e: np.ndarray
        A numpy array of the event/censoring indicators, \( \delta \).

        \( \delta = 1 \) means the event took place.
    vsize: float
        Amount of data to set aside as the validation set.
    iters: int
        The maximum number of training iterations on the training dataset.
    learning_rate: float
        The learning rate for the `Adam` optimizer.
    batch_size: int
        learning is performed on mini-batches of input data. this parameter
        specifies the size of each mini-batch.
    elbo: bool
        Whether to use the Evidence Lower Bound for Optimization.
        Default is True.
    optimizer: str
        The choice of the gradient based optimization method. One of 
        &#39;Adam&#39;, &#39;RMSProp&#39; or &#39;SGD&#39;.
    random_state: float
        random seed that determines how the validation set is chosen.
    &#34;&#34;&#34;

    idx = list(range(x.shape[0]))
    np.random.seed(random_state)
    np.random.shuffle(idx)
    x_train, t_train, e_train = x[idx], t[idx], e[idx]

    x_train = torch.from_numpy(x_train).double()
    t_train = torch.from_numpy(t_train).double()
    e_train = torch.from_numpy(e_train).double()

    vsize = int(vsize*x_train.shape[0])

    x_val, t_val, e_val = x_train[-vsize:], t_train[-vsize:], e_train[-vsize:]
    x_train = x_train[:-vsize]
    t_train = t_train[:-vsize]
    e_train = e_train[:-vsize]

    inputdim = x_train.shape[1]

    if type(self).__name__ == &#34;DeepSurvivalMachines&#34;:

      model = DeepSurvivalMachinesTorch(inputdim,
                                        k=self.k,
                                        layers=self.layers,
                                        init=False, 
                                        dist=self.dist,
                                        temp=self.temp,
                                        discount=self.discount,
                                        optimizer=optimizer)

      model, _ = train_dsm(model, x_train, t_train, e_train,
                           x_val, t_val, e_val,
                           n_iter=iters,
                           lr=learning_rate,
                           elbo=elbo,
                           bs=batch_size)

      self.torch_model = model.eval()
      self.fitted = True

    else:
      raise NotImplementedError(&#34;`fit` nethod not implemented for &#34;+
                                type(self).__name__)


  def predict_risk(self, x, t):
    &#34;&#34;&#34;Returns the estimated risk of an event occuring before time \( t \),
      \( \widehat{\mathbb{P}}(T\leq t|X) \) for some input data \( x \).

    Parameters
    ----------
    x: np.ndarray
        A numpy array of the input features, \( x \).
    t: list or float
        a list or float of the times at which survival probability is
        to be computed
    Returns:
      np.array: numpy array of the risks at each time in t.
    &#34;&#34;&#34;

    if self.fitted:
      return 1-self.predict_survival(x, t)

    else:
      raise Exception(&#34;The model has not been fitted yet. Please fit the &#34; +
                      &#34;model using the `fit` method on some training data &#34; +
                      &#34;before calling `predict_survival`.&#34;)


  def predict_survival(self, x, t):
    &#34;&#34;&#34;Returns the estimated survival probability at time \( t \),
      \( \widehat{\mathbb{P}}(T &gt; t|X) \) for some input data \( x \).

    Parameters
    ----------
    x: np.ndarray
        A numpy array of the input features, \( x \).
    t: list or float
        a list or float of the times at which survival probability is
        to be computed
    Returns:
      np.array: numpy array of the survival probabilites at each time in t.
    &#34;&#34;&#34;

    if not isinstance(t, list):
      t = [t]

    if self.fitted:
      x = torch.from_numpy(x)
      scores = predict_cdf(self.torch_model, x, t)
      return np.exp(np.array(scores)).T

    else:
      raise Exception(&#34;The model has not been fitted yet. Please fit the &#34; +
                      &#34;model using the `fit` method on some training data &#34; +
                      &#34;before calling `predict_risk`.&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="dsm.dsm_api.DeepRecurrentSurvivalMachines" href="#dsm.dsm_api.DeepRecurrentSurvivalMachines">DeepRecurrentSurvivalMachines</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dsm.dsm_api.DeepSurvivalMachines.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, x, t, e, vsize=0.15, iters=1, learning_rate=0.001, batch_size=100, elbo=True, optimizer='Adam', random_state=100)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is used to train an instance of the DSM model.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A numpy array of the input features, <span><span class="MathJax_Preview"> x </span><script type="math/tex"> x </script></span>.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A numpy array of the event/censoring times, <span><span class="MathJax_Preview"> t </span><script type="math/tex"> t </script></span>.</dd>
<dt><strong><code>e</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>
<p>A numpy array of the event/censoring indicators, <span><span class="MathJax_Preview"> \delta </span><script type="math/tex"> \delta </script></span>.</p>
<p><span><span class="MathJax_Preview"> \delta = 1 </span><script type="math/tex"> \delta = 1 </script></span> means the event took place.</p>
</dd>
<dt><strong><code>vsize</code></strong> :&ensp;<code>float</code></dt>
<dd>Amount of data to set aside as the validation set.</dd>
<dt><strong><code>iters</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum number of training iterations on the training dataset.</dd>
<dt><strong><code>learning_rate</code></strong> :&ensp;<code>float</code></dt>
<dd>The learning rate for the <code>Adam</code> optimizer.</dd>
<dt><strong><code>batch_size</code></strong> :&ensp;<code>int</code></dt>
<dd>learning is performed on mini-batches of input data. this parameter
specifies the size of each mini-batch.</dd>
<dt><strong><code>elbo</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to use the Evidence Lower Bound for Optimization.
Default is True.</dd>
<dt><strong><code>optimizer</code></strong> :&ensp;<code>str</code></dt>
<dd>The choice of the gradient based optimization method. One of
'Adam', 'RMSProp' or 'SGD'.</dd>
<dt><strong><code>random_state</code></strong> :&ensp;<code>float</code></dt>
<dd>random seed that determines how the validation set is chosen.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(self, x, t, e, vsize=0.15, 
        iters=1, learning_rate=1e-3, batch_size=100,
        elbo=True, optimizer=&#34;Adam&#34;, random_state=100):

  &#34;&#34;&#34;This method is used to train an instance of the DSM model.

  Parameters
  ----------
  x: np.ndarray
      A numpy array of the input features, \( x \).
  t: np.ndarray
      A numpy array of the event/censoring times, \( t \).
  e: np.ndarray
      A numpy array of the event/censoring indicators, \( \delta \).

      \( \delta = 1 \) means the event took place.
  vsize: float
      Amount of data to set aside as the validation set.
  iters: int
      The maximum number of training iterations on the training dataset.
  learning_rate: float
      The learning rate for the `Adam` optimizer.
  batch_size: int
      learning is performed on mini-batches of input data. this parameter
      specifies the size of each mini-batch.
  elbo: bool
      Whether to use the Evidence Lower Bound for Optimization.
      Default is True.
  optimizer: str
      The choice of the gradient based optimization method. One of 
      &#39;Adam&#39;, &#39;RMSProp&#39; or &#39;SGD&#39;.
  random_state: float
      random seed that determines how the validation set is chosen.
  &#34;&#34;&#34;

  idx = list(range(x.shape[0]))
  np.random.seed(random_state)
  np.random.shuffle(idx)
  x_train, t_train, e_train = x[idx], t[idx], e[idx]

  x_train = torch.from_numpy(x_train).double()
  t_train = torch.from_numpy(t_train).double()
  e_train = torch.from_numpy(e_train).double()

  vsize = int(vsize*x_train.shape[0])

  x_val, t_val, e_val = x_train[-vsize:], t_train[-vsize:], e_train[-vsize:]
  x_train = x_train[:-vsize]
  t_train = t_train[:-vsize]
  e_train = e_train[:-vsize]

  inputdim = x_train.shape[1]

  if type(self).__name__ == &#34;DeepSurvivalMachines&#34;:

    model = DeepSurvivalMachinesTorch(inputdim,
                                      k=self.k,
                                      layers=self.layers,
                                      init=False, 
                                      dist=self.dist,
                                      temp=self.temp,
                                      discount=self.discount,
                                      optimizer=optimizer)

    model, _ = train_dsm(model, x_train, t_train, e_train,
                         x_val, t_val, e_val,
                         n_iter=iters,
                         lr=learning_rate,
                         elbo=elbo,
                         bs=batch_size)

    self.torch_model = model.eval()
    self.fitted = True

  else:
    raise NotImplementedError(&#34;`fit` nethod not implemented for &#34;+
                              type(self).__name__)</code></pre>
</details>
</dd>
<dt id="dsm.dsm_api.DeepSurvivalMachines.predict_risk"><code class="name flex">
<span>def <span class="ident">predict_risk</span></span>(<span>self, x, t)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the estimated risk of an event occuring before time <span><span class="MathJax_Preview"> t </span><script type="math/tex"> t </script></span>,
<span><span class="MathJax_Preview"> \widehat{\mathbb{P}}(T\leq t|X) </span><script type="math/tex"> \widehat{\mathbb{P}}(T\leq t|X) </script></span> for some input data <span><span class="MathJax_Preview"> x </span><script type="math/tex"> x </script></span>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A numpy array of the input features, <span><span class="MathJax_Preview"> x </span><script type="math/tex"> x </script></span>.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>list</code> or <code>float</code></dt>
<dd>a list or float of the times at which survival probability is
to be computed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.array</code></dt>
<dd>numpy array of the risks at each time in t.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict_risk(self, x, t):
  &#34;&#34;&#34;Returns the estimated risk of an event occuring before time \( t \),
    \( \widehat{\mathbb{P}}(T\leq t|X) \) for some input data \( x \).

  Parameters
  ----------
  x: np.ndarray
      A numpy array of the input features, \( x \).
  t: list or float
      a list or float of the times at which survival probability is
      to be computed
  Returns:
    np.array: numpy array of the risks at each time in t.
  &#34;&#34;&#34;

  if self.fitted:
    return 1-self.predict_survival(x, t)

  else:
    raise Exception(&#34;The model has not been fitted yet. Please fit the &#34; +
                    &#34;model using the `fit` method on some training data &#34; +
                    &#34;before calling `predict_survival`.&#34;)</code></pre>
</details>
</dd>
<dt id="dsm.dsm_api.DeepSurvivalMachines.predict_survival"><code class="name flex">
<span>def <span class="ident">predict_survival</span></span>(<span>self, x, t)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the estimated survival probability at time <span><span class="MathJax_Preview"> t </span><script type="math/tex"> t </script></span>,
<span><span class="MathJax_Preview"> \widehat{\mathbb{P}}(T &gt; t|X) </span><script type="math/tex"> \widehat{\mathbb{P}}(T > t|X) </script></span> for some input data <span><span class="MathJax_Preview"> x </span><script type="math/tex"> x </script></span>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A numpy array of the input features, <span><span class="MathJax_Preview"> x </span><script type="math/tex"> x </script></span>.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>list</code> or <code>float</code></dt>
<dd>a list or float of the times at which survival probability is
to be computed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.array</code></dt>
<dd>numpy array of the survival probabilites at each time in t.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict_survival(self, x, t):
  &#34;&#34;&#34;Returns the estimated survival probability at time \( t \),
    \( \widehat{\mathbb{P}}(T &gt; t|X) \) for some input data \( x \).

  Parameters
  ----------
  x: np.ndarray
      A numpy array of the input features, \( x \).
  t: list or float
      a list or float of the times at which survival probability is
      to be computed
  Returns:
    np.array: numpy array of the survival probabilites at each time in t.
  &#34;&#34;&#34;

  if not isinstance(t, list):
    t = [t]

  if self.fitted:
    x = torch.from_numpy(x)
    scores = predict_cdf(self.torch_model, x, t)
    return np.exp(np.array(scores)).T

  else:
    raise Exception(&#34;The model has not been fitted yet. Please fit the &#34; +
                    &#34;model using the `fit` method on some training data &#34; +
                    &#34;before calling `predict_risk`.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dsm" href="index.html">dsm</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dsm.dsm_api.DeepConvolutionalSurvivalMachines" href="#dsm.dsm_api.DeepConvolutionalSurvivalMachines">DeepConvolutionalSurvivalMachines</a></code></h4>
</li>
<li>
<h4><code><a title="dsm.dsm_api.DeepRecurrentSurvivalMachines" href="#dsm.dsm_api.DeepRecurrentSurvivalMachines">DeepRecurrentSurvivalMachines</a></code></h4>
</li>
<li>
<h4><code><a title="dsm.dsm_api.DeepSurvivalMachines" href="#dsm.dsm_api.DeepSurvivalMachines">DeepSurvivalMachines</a></code></h4>
<ul class="">
<li><code><a title="dsm.dsm_api.DeepSurvivalMachines.fit" href="#dsm.dsm_api.DeepSurvivalMachines.fit">fit</a></code></li>
<li><code><a title="dsm.dsm_api.DeepSurvivalMachines.predict_risk" href="#dsm.dsm_api.DeepSurvivalMachines.predict_risk">predict_risk</a></code></li>
<li><code><a title="dsm.dsm_api.DeepSurvivalMachines.predict_survival" href="#dsm.dsm_api.DeepSurvivalMachines.predict_survival">predict_survival</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>